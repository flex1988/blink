#!/usr/bin/stap

# 这里核心的想法就是通过systemtap 找到malloc, realloc 返回的地址, 
# 可以通过systemtap 里面的$return 来获得, 并记录, 然后再记录free 的时候是否对这些地址进行过free. 
# 可以通过 $ptr 来获得. 具体的systemtap 用法可以看官网

probe begin
{
  log("begin to probe\n")
}

# 对某一个地址调用的malloc, free的次数. 
# 如果 = 0, 说明正常free掉, 
# 如果 = 1, 说明malloc, 但是还没被free
# 如果 > 1, 说明这个地址被多次给malloc返回给用户, 肯定不正常
# 如果 < 1, 说明这个地址被多次free 也就是我们常说的double free 问题
global g_cnt
# 用来记录前一次调用的时候的 ubacktrace 信息
global g_stack
# 用来记录上次操作的时间
global g_time

# 每一次malloc, realloc 最后都会调到glic 里面的__libc_malloc, __libc_calloc
probe process("/usr/local/pika22/lib/libtcmalloc.so.4").function("__libc_malloc").return, process("/usr/local/pika22/lib/libtcmalloc.so.4").function("__libc_calloc").return

{
	if (tid() == 11808) {
			g_cnt[$return]++
			g_stack[$return] = sprint_ubacktrace()
			g_time[$return] = gettimeofday_s()
	}
}

probe process("/usr/local/pika22/lib/libtcmalloc.so.4").function("__libc_free") {
	if (tid() == 11808 && g_time[$ptr] != 0) {
    # 这里对于之前没有进行过处理的节点忽略
    g_cnt[$ptr]--
    # 正常的malloc free 分支
		if (g_cnt[$ptr] == 0) {
			if ($ptr != 0) {
				printf("A normal malloc and free\n")
				g_stack[$ptr] = sprint_ubacktrace()
			}
      # 可能出现的double free 分支
		} else if (g_cnt[$ptr] < 0 && $ptr != 0) {
				printf("double free problem address %d cnt %d\n", $ptr, g_cnt[$ptr])
				printf("%s\n", g_stack[$ptr])
				printf("the destructure \n")
				print_ubacktrace() 
      # 多次malloc 返回同一个地址的分支, 这种情况很少见
		} else if (g_cnt[$ptr] > 1 && $ptr != 0) {
			printf("malloc large than 0\n")
			print_ubacktrace()
		}
	}
}

probe timer.s(5) {
	foreach (mem in g_cnt) {
    # 这里可以根据定义来调整这个10 的大小, 也就是说这里想打印出 10s 之前申请过内存
    # 但是 10s 之内没有被free 的情况, 这里因为 pika 在短连接的时候都是10之内申请 然后就释放
    # 如果10s 之内没有释放, 那肯定就是内存出现了问题
		if (g_cnt[mem] > 0 && gettimeofday_s() - g_time[mem] > 10) {
			printf("\n\n%s\n\n", g_stack[mem])
		}
	}
}
